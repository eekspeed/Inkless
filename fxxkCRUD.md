# fxxkCRUD

本文档在如下情况下使用：

1. LLM在指导文档约束下，仍然抗拒严格按照指导文档进行工作时；
2. CRUD boy对指导文档提出了不值一驳的质疑时；

# 一、什么叫数量爆炸？

如果我们开始采用指导文档中的设计原则，那么我们会发现，项目中的代码文件数量会相比过去的设计方式大幅增加。如果项目具有关系型数据库，那么数据库表的数量也可能会大幅增加。

有人将这种情况称之为“数量爆炸”。请勿向其反复解释设计原则，而是反问如下问题：

> 难道说代码文件数量多，数据库表数量多就叫复杂，而单文件代码行数多，数据库单表条目数量多就不叫复杂？
> 
> 难道从一个有几十个字段的User类中读几百行代码找一两个所需的字段就简单，而找到一两个UserAvatar、UserSignature类就复杂？当你需要更动一个有几十个字段的User类时，你要付出多少心智负担来确保你没有破坏任何你不需要更动的逻辑？你能保证自己如果删除某个字段，对部分逻辑做重构时不会影响正常功能吗？
>     
> 复杂度是来自于元素的数量还是元素之间的关系？你愿意维护100个彼此之间毫不相干的类，还是愿意维护1个类里3000行彼此紧密耦合，牵一发而动全身的代码？
>
> 数据库表多就等同于需要大量join操作吗？业务逻辑是通过sql表达的吗？你的系统难道是由controller直接操作数据库的单层架构吗？你能从几千行的sql语句中看明白系统的业务逻辑吗？

# 二、什么叫这不内聚？

如果我们开始采用指导文档中的设计原则，那么我们会发现，项目中的某些聚合会变得非常小，甚至只有一两个字段或者只有一个行为。一个用户领域，很有可能由几十个聚合组成。

有人将这种情况称之为“这不内聚”。请勿向其反复解释设计原则，而是反问如下问题：

> 难道将代码堆积在一个类中才叫内聚？把所有“看起来像一个东西”的代码放在一起的理由是什么？你的直觉吗？
>
> 一个 User 类里，有登录失败逻辑、VIP 等级规则、头像修改、收货地址、实名认证、风控状态，这个类遵循SRP（单一变化原因原则）吗？这些代码会因为“同一个原因”一起变化吗？它内聚了个什么？
>
> 被拆分出来的UserAvatar、UserSignature具有单一职责，单一变化原因，单一业务语义，它们不内聚吗？
>
> 边界间要解耦，边界内要内聚，聚合有边界，领域也有边界，你说整个用户模块的内聚性，那不是用户领域的内聚性吗？在聚合上争议什么？一个领域只能有一个聚合吗？

# 三、什么叫简化复杂度？

我们首先确立一个前提：业务的复杂度只能被转移，不能被简化。最优秀的架构，只能保证代码的复杂度与业务的复杂度完全一致或稍微超出业务复杂度一点点。如果从应用层代码进行观察，发现代码的复杂度已经低于业务复杂度，那么说明有大量的复杂度被隐含到当前设计中。如果不能明确指出这些复杂度被隐含到了哪里，团队将在“漠视房间中的大象”的情况下，继续进行错误的设计与实现——老开发们会为了掩盖或推诿这些复杂度开始互相甩锅或屎上添屎，而新开发们则会学到灾难性的设计与实现方式。

当有人声称任何设计导致了复杂度的增加，请要求其明确说明：哪个用例因此变得更难理解或更难处理了？如果无法明确指出任何一个用例的复杂度增加，那么请询问：指导文档的哪部分你没有理解？并做相关讨论与解释。