笔者在学习依赖注入的时候遇到过两个令人困惑的术语：依赖倒置和控制反转。依赖倒置告诉我们上层模块不应该依赖于下层模块，二者都应该依赖于抽象；而控制反转则告诉我们不要自己去创建对象，而是通过外部容器来创建对象并注入到类中。

对于20年前的程序员们，他们很容易就能理解这两个概念，因为他们已经习惯于让上层模块依赖于下层模块，并且在各种上层模块中直接创建下层模块的实例。于是当他们遇到“倒置”和“反转”时，他们立刻理解了”倒置”和“反转”具体倒置了、反转了什么。

然所谓阴阳相生，无正则无反，今天的程序员们从开始学习编程起，就被教导要依赖抽象、面向接口编程，并且使用各种依赖注入框架来管理对象的创建和生命周期。他们从来就没有见过过去“正向”的做法，自然也就无法理解“倒置”和“反转”。如果我们抛开技术，从人的朴素理解的角度上思考，一个被编写的程序就像是一个工作人员，他需要使用各种工具来完成工作。因此该工作人员持有它需要的所有工具是自然而合理的，由此落地到代码上，就是类自己创建它所依赖的对象是理所当然的事情，于是早年的程序的确都这样写出来了。我们可以说，曾经这样“正向依赖”“正向控制”的代码编写方式来自于人的“生活哲学”。而依赖倒置和控制反转的诞生呢？这个问题在历史上存在一个答案，但我们并不必深究软件开发历史去找这个答案，因为最终的答案是确定的：无论曾经提出——或者说，总结——这些概念的人们的初衷是“应对技术上的挑战”还是“从生活哲学上反思编程实践”，归根结底，依赖倒置和控制反转被人们所认可，正是因为人们在生活中找到了类似的哲学依据。软件开发应对的是现实世界的业务问题，那软件开发的原则就应当与现实世界的哲学原则相契合。

在现实世界，类似与“依赖倒置”“控制反转”的哲学思想其实并不陌生。当处理业务的从“少量工作人员”变成“大型企业”时，企业的组织结构也经历了类似的变化。过去一个小作坊里，老板亲自雇佣工人，工人直接向老板汇报工作，老板直接管理工人的工作内容和工作方式，这就像是“正向依赖”“正向控制”。但随着企业规模的扩大，老板不可能再亲自管理每一个工人了，于是企业引入了中层管理者，工人们不再直接向老板汇报，而是向中层管理者汇报工作，中层管理者再向老板汇报，中层管理充当了“抽象”的角色，老板和工人都依赖于中层管理者，这就像是“依赖倒置”。工人们曾经需要自行持有所有的工具来完成工作，但随着企业的发展，企业开始为工人们提供统一的工具和资源，工人们不再需要自己去购买和维护工具，而是通过企业提供的资源来完成工作，这就像是“控制反转”。我们可以从企业组织结构的发展中看到，这些改变为我们带来了“关键人员心智负担的减轻”、“业务分工的精细化、专业化、简单化”、“不依赖于具体工作人员也可持续运行的组织结构”等诸多好处。而将这些哲学思想应用到软件开发中，也带来了类似的好处：降低了开发者的心智负担，每个具体的开发者只需要对划分明确的模块负责，而不需要关心其他模块的实现细节；项目在开发时不需要关心具体的开发者的能力和水平，只需要将开发者安排到各个工作组中即可，从而让开发效率成功打破了“人月神话”所指出的边际递减效应的瓶颈，实现了人数-效率近乎线性的增长。

基于上述的逻辑，笔者写出了本文的标题：编程的第一美德是愚蠢，第一原罪是显摆。所谓“愚蠢”，即软件开发的原则应当直接来自于现实世界的哲学原则，使得任何人都能直观地理解这些原则，而不需要任何技术上的背景门槛；所谓“显摆”，即我们不应当抛开现实世界的哲学原则，去总结出某些看起来高大上的技术原则。笔者并不明白建立这种认识门槛的意义何在，行业外人士指责程序员“傲慢”的时候，我们自己应当识别到“傲慢”指向的问题所在——软件开发的原则、方法和代码落地应当是人人皆可理解的内容，而不是少数技术专家才能理解的高深知识。如果软件开发行业的含金量只能由业内自行识别确认，拒绝其他人的理解和审视，那整个行业离死不远了。从这个角度上看，正在拯救编程界的既不是工业界也不是学术界，而是无数无私奉献的技术分享小视频、教培和会写代码的哲学家（笑）。

笔者曾经想写一篇文章叫“技术有政治底色”，受限于眼界与时间，终究未能成文。笔者至今难以彻底而完整的解释软件开发技术的政治底色，仅从大体上能识别到数量众多的思想/主义在其背后错综复杂的交织，但要将这些思想/主义的影响一一剖析出来，实在是力有不逮。而时至今日，笔者发现仅将追根溯源、寻找指导思想的任务推导到“政治”层面，仍然没有触及更加根本的“哲学”层面。只能指导特定领域的叫技术，能指导一个民族的发展、一个国家的运转的叫政治，能指导人类生活的方方面面的才叫哲学。我们通常称一个领域的最核心的哲学为“第一性原理”，例如数学的第一性原理是“可解释性”，即“任何有效结论都必须能在形式系统中被完全解释为其前提的必然结果”。那么，软件开发是否存在“第一性原理”？这个问题时至今日仍然难以回答。当笔者尝试追溯我们在工作中常见的各种设计原则和模式其背后的根源时，几乎只能看到从技术上的解释和来自于工作经验的总结，而无法更上一层楼，找到这些原则和模式背后的根本依据，像是数学中的公理那样被无可辩驳地接受。

还好笔者至今并非毫无收获。笔者在各种文章中反复提到“软件工程的两大原则”：

1. 尽可能的降低程序员的心智负担。
2. 在尽可能不增加程序员心智负担的基础上，尽可能增加同时参与项目中的程序员数量。

笔者之所以反复强调这两大原则，是因为笔者提出这两大原则是**有**背后的“第一性原理”支撑的：即“人文主义”（笔者指的是那个可以被译为“人本主义”的Humanism）。软件开发再怎么处理各种独特的业务，再怎么为了业务的特性而做工作上的妥协，我们都必须时刻牢记软件开发的参与者都是人，软件开发的目标也是为了服务于人。因此，软件开发的原则和模式必须以“尊重人、理解人、服务于人”为根本出发点和落脚点，明确反对“业务至上”“技术至上”的导向，坚持“以人为本”的理念，在不断的开发和维护中，让软件开发工作向以人为本的方向发展。（啊，当然，笔者清楚的意识到我们开发者很多时候在工作时遇到的导向是“金钱至上”，最糟糕的结果是企业和开发者本人都被资本所异化，那笔者对此无可奈何；好一些的情况是开发者仍然具有人文主义的光辉，只是不得不在资本的压力下妥协，在这种情况下，笔者期望你能想办法夺取部分主导权，为你身为人的伟大性争取空间。正所谓安得草屋三两间，**风雨不动安如山**。）

如今，笔者越发能将从行业内了解到的各种技术上的原则和模式，与现实世界的哲学对应起来。而这样一种探索使笔者认识到了某些令人惊悚的事实：技术并非中立，而是天生具有善恶倾向的，所谓“技术有政治底色”的判断在笔者脑中愈发清晰而被反复证明，所谓“技术最终的善恶表现取决于我们如何使用技术”是伪命题，事实很有可能恰恰相反，是技术本身决定了我们如何使用技术，从而表现出技术天生的善恶倾向。如果以上所说在未来被笔者严格论证并确认，那就说明我们软件开发者的“聪明”正在为整个行业乃至全世界带来灾难性的后果，而那时，必须有勇者找到软件开发的第一性原理这柄圣剑，为拯救我们所有人而战斗。而在那之前，笔者将尝试继续将人文主义带回到软件开发中来，至少在异鬼大举入侵之前，作为守夜人守好一段北境长城。